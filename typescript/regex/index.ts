// (1) 匹配：判断一个字符串是否满足我们制定的规则
const reg = /\d/ // 包含一个数字类型的字符串
console.log(reg.test('1'))

// (2) 捕获：制定一个规则，让它到一个字符串当中捕获符合这个规则的内容
const reg1 = /^\d$/ // 只能包含一个数字类型的字符串
console.log(reg1.exec('100')) // 这个包含了3个数字类型，所以找不到

/*
 1. 代表特殊意义的元字符
 \: 转义字符， 将放在转移字符后边的元字符的原始意思去除(让一个具有特殊意思的字符没有任何意义了，让一个没有任何意义的字符，转换成具有特殊意义的元字符)
 ^: 代表开头
 $: 代表结尾
 .: 处理\n以外的任意字符
 (): 给字符分组 【分组可以改变正则的优先级】
 x|y: x或者y
 [xyz]: x或者y或者z
 [^xyz]: 除了(xyz)之外的字符
 [a-z]: a-z中的一个字符
 [^a-z]: 除了a-z中的任意一个字符
 \d: 一个数字
 \b: 一个边界符
 \w: 数字、字母、下划线中的任意一个字符[0-9a-zA-Z_]
 \s: 一个空白字符/空格/制表符/换页符
 []: 中括号当中出现的字符都是本身意思 
*/

/*
  2. 代表数量的字符 [如果在量词后边加？,意思是取消正则捕获时候的贪婪性]
  *: 代表0<=x个   [0,∞) 它是 [n,∞]的一种特殊情况 {n,}: 代表n<=x个 [n,∞]
  +: 代表1<=x个   [1,∞) 它是 [n,∞]的一种特殊情况 {n,}: 代表n<=x个 [n,∞]
  ?: 代表0<=x<=1 [0,1]  它是 {n,m}的一种特殊情况  {n,m}: 代表n<=x<=m个 [n,m]
  {n}: 代表n=x个  [n]
  {n,}: 代表n<=x个 [n,∞]
  {n,m}: 代表n<=x<=m个 [n,m]
*/
const reg2 = /\d+/ // 包含>=1个数字的字符串
console.log(reg2.test('1000'))
console.log(reg2.exec('1000'))

const reg3 = /^\d+$/ //只能包含>=1个数字的字符串
console.log(reg3.test('1000s'))

const reg4 = /\d+?/
console.log(reg4.exec('83739'))

const reg5 = /\d+?/g // 要用修饰符解决正则的惰性
console.log('12345'.match(reg5)) // match相当于循环执行test.exec()的捕获结果。但match只适合捕获大分组的内容

/*
正则分组的作用：
1. 改变优先级
2. 分组引用
 */
