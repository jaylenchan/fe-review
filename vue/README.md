# Vue 面试题

1. 谈谈你对MVVM的理解
   - 谈MVVM发展历程 ：MVC到MVVM的发展
   - 谈Object.defineProperty作用
   - 谈依赖收集和视图更新

2. Vue2中是如何检测数组变化的
   - 谈数组方法重写
   - 谈当数组当中有元素是对象要咋做
   - vue2中没有使用对数组当中的每一项进行拦截，而是选择重写数组，比如说push,splice等数组方法。不过如果数组里头的元素是对象的话，还是会使用Object.defineProperty进行递归数据劫持。数组的长度和索引的变化是没办法监控的。

3. 为什么Vue采用异步渲染
   -因为如果不采用异步更新，那么每次更新数组都会对当前组件进行重新渲染。因此为了性能考虑，vue会在本轮数据更新之后，再去异步更新视图。

4. nextTick实现原理？
   - 主要利用事件循环机制（宏任务和微任务），定义一个异步方法，多次调用nextTick会将方法存入队列当中，通过这个异步方法清空队列。
   - 使用nextTick回调函数，在下一次DOM更新循环结束之后，执行nextTick中的回调函数。一般用在DOM操作完成后，立马想要获取更新后的DOM和相关的DOM数据。
   - 为啥有这个东西，是因为vue中的视图更新是异步的，使用nextTick就可以保证用户定义的逻辑在更新之后执行起来。
  
5. Vue2中computed的特点
   - computed是一个具备缓存的watcher，只有当依赖属性变化的时候才会更新
  
6. watch中的deep:true是如何实现的
   - 当用户使用了上述配置时，如果说当前监控的值是一个数组，就会对对象中的每一项进行求值，此时会将当前watcher存入到对应属性的依赖当中，当数组中对象发生变化的时候就会通知数据更新

7. Vue2组件的生命周期
   - 嗷嗷

8. ajax请求放在哪个生命周期
   - created：视图中的真实dom并没有渲染出来，此时没法操作dom
   - mounted：视图中的真实dom渲染出来了，此时可以操作dom

9. 何时需要使用beforeDestroy
   - 当前页面中如果使用了$on方法，那么需要在组件销毁前解绑
   - 清除自己定义的定时器
   - 解除元素原生事件的绑定

10. Vue中模板编译原理
    - 将模板转化成ast树 -》虚拟dom
    - 树的优化
    - 将ast树重新生成代码 -》render方法
11. v-if和v-show的区别
    - v-if如果条件不成立，不会渲染当前指令所在节点的dom元素
    - v-show只是切换当前dom的现实或者隐藏

12. 为什么v-if和v-show不能连用
    - v-for的优先级比v-if的要早
    - 源码的操作时让元素先遍历，然后再判断，这种方式的话如果有1万个节点，就要判断一万次。而我们想要的做法就是先判断是不是需要渲染，不需要就不用遍历出来了。解决的做法是将v-if放到上级父级容器中

13. vue2-diff算法的原理？
    - diff实现利用了递归（广度优先遍历）+双指针
    - 首先判断是不是同一个元素，不是同一个元素直接替换
    - 如果是同一个元素
      - 比对属性，看看属性是否相同。
      - 比对子元素：
        - 老的有儿子，新的没有儿子。直接删除老儿子
        - 老的没儿子，新的有儿子。递归添加创建儿子
        - 如果是文本的情况，那就创建文本
        - 老的有儿子，新的有儿子。利用双指针，头头比较，尾尾比较，头尾比较，尾头比较。对比查找之后进行复用。

14. v-for中key的作用和原理
    - vue在patch过程中会利用到这个key去判断两个虚拟节点是否相同，如果相同的话，就可以直接复用老的节点。那如果没有key的话，就不好判断了，这就会导致更新的时候出错。在实际工程上，如果没给key，或者直接key赋值index，可能会让当前的节点进行复用，而只是更改文本，这样的话会导致渲染错误，因此遍历的时候要记得给上一个key。不过如果不需要交互，如果只是单纯的静态列表，那么可以给index作为key。

15. 描述组件渲染和更新过程
    - 渲染组件的时候，会通过Vue.extend方法构建子组件的构造函数，并进行实例化。最终手动调用$mount()进行挂载。更新组件时，会进行patchVnode过程，这里头的核心就是diff算法。

16. 组件中的data为什么是一个函数

    ```js
      function Component() {}
       Component.prototype.$options = {
          data: {name: 'jaylen'}
       }
       const v1 = new Component()
       const v2 = new Component()
       v2.$options.data.name = 'jay'
       // v1也会改变
       // 所以data必须是一个函数
    ```
