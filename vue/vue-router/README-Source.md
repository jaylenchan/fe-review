# Vue-Router Source

## 浏览器历史记录

浏览器的历史记录，内部是通过两个栈去实现的。当你访问`www.taobao.com`的时候，会将该记录压入栈A中，页面来到了淘宝首页。然后再访问`www.jingdong.com`，就会将该记录继续压入栈A中， 页面来到了京东首页。此时你可以看到其实浏览器的后退箭头已经是高亮的状态。当你去点击后退的时候，网页从京东回到了淘宝，而浏览器历史记录，栈A就会pop弹出栈顶元素，就是京东的记录，将其放入栈B中。因此，我们可以理解成，浏览器当前呈现的就是栈A栈顶的记录对应的网页。
但是这个时候，如果你继续输入`www.qq.com`的时候，又会继续压栈，将qq的记录压入栈A。同时还会清空栈B，也就是京东的记录会被清除。所以当你点击后退的时候，浏览器又回到了淘宝页面。因为此时弹出栈顶元素，也就是qq的记录，将该记录压入了栈B。
从这时候，你就再也找不回京东的记录了。栈A只有淘宝记录，栈B只有京东记录。当你点击右键头的时候，前进就会把栈B的记录弹出，压回栈A，于是浏览器继续取栈顶的记录，就看到qq的页面回来了。

## 前端路由

前端路由实现的两种方案：`hash`和`history` 。

### `hash`模式

1. 使用hash的方式可以在url当中产生锚点，比如说`www.baidu.com/#aa`，然后再输入`www.baidu.com/#bb`。页面不会刷新的同时，也会在浏览器当中产生历史记录，可以让你前进和后退。

结论1: `URL hash`可以产生浏览器历史记录

2. 为了让hash更像我们的路由而不是普通的锚点。我们做了进一步修改，将`www.baidu.com/#aa`改成了`www.baidu.com/#/aa`。即，将`#aa`变成`#/aa`，让路径看起来更像是来到了路由`/aa`。然后在这样子的路径改变的时候，我们就改变视图，而且不会引起页面刷新。为了达到如上的效果，我们可以使用api`window.location.hash = /aa`。它会自动在`/aa`前边拼接上`#`hash前缀。变成`#/aa`，于是你就可以看到`www.baidu.com`变成了`www.baidu.com/#/aa`。这样就引起了hash的变化，而hash的变化就会触发一个事件，叫做`hashchange`，因此我们就可以监听hash的变化，然后根据不同的hash路径，取将对应的视图展示出来。

### `history`模式

1. 使用hash模式可以完成我们想要的效果。但是用上hash模式的url会显的比较丑陋。我们可能更想要让url变成我们习惯的样子，即`www.baidu.com/aa`而不是`www.baidu.com/#/aa`。那么我们该如何做呢？
   利用浏览器api`window.history.pushState`其实也可以让路径变化并且也不会让页面刷新。因此我们可以利用api`window.history.pushState({}, null, '/aa')`（假设现在是`www.baidu.com`），调用之后，我们真的在浏览器url看到url变化了，从`www.baidu.com`变成了`www.baidu.com/aa`。并且我们的页面并没有刷新。同时我们还看到，这个api同样会产生历史记录，就跟hash模式一样。

2. 但是这毕竟是我们自己虚拟出来的路径，当我们在url上点击高亮，然后回车强制刷新的时候，浏览器就会真实去向服务器请求这个路径。而加入服务器没有这个路径的时候，往往就会报错。（因此我们后期要使用history的时候，需要利用服务器去解决这个问题）

3. 遗憾的是，`window.history`模式下，我们并没有办法像hash模式那样，可以有办法直接监控到通过history.pushState改变的路径变化。但是我们有window.onpopstate事件，它会在点击前进和后退或者使用脚本前进和后退，或者hash变化时触发。
